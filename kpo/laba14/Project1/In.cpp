#include "Error.h"
#include "stdafx.h"
#include "In.h"
using namespace std;

namespace In {
	iN getin(wchar_t name[]) {
		iN in;
		bool check = false;
		in.size = 0; // количество символов
		in.ignor = 0; // количество проигнорированных символов
		in.lines = 1; // количество строк
		int col = 1; // переменная для позиции в строке
		unsigned char* text = new unsigned char[IN_MAX_LEN_TEXT]; // буферный массив для записи текста
		ifstream fin(name); // открытие файла для чтения
		if (!fin.is_open()) { // если не удалось открыть файл
			throw ERROR_THROW(110); // выбрасываем исключение
		}
		while (in.size < IN_MAX_LEN_TEXT) { // пока доступное место не закончилось
			char c; // буферная переменная для чтения
			fin.get(c); // считываем текущий символ
			unsigned char x = c; // заводим новую переменную без знака, т.к. есть русский язык
			//cout << x << ' ';
			if (fin.eof()) { // если конец файла
				text[in.size] = '\0'; // записываем текущий символ как конец текста
				break; // выходим из цикла
			}
			switch (in.code[x]) { // иначе смотрим, что нужно сделать с текущим символом
			case in.T: { // если он находится в доступных 
				text[in.size] = x; // записываем его в буферный массив
				in.size++; // увеличиваем количество считанных символов
				col++; // увеличиваем позицию в строке
				break;
			}
			case in.I: { // если он находится в категории для игнорирования
				in.ignor++; // увеличиваем количество проигнорированных символов
				col++; // увеличиваем позицию  в строке
				break;
			}
			case in.F: { // если он находится в категории недопустимых
				throw ERROR_THROW_IN(111, in.lines, col); // вызываем исключение, передавая текущую строку и позицию  в строке
				break;
			}
			default: { // если встретился символ, не соответствующий этим категориям
				text[in.size] = in.code[x]; // записываем в буферный массив символ, который соответствует коду в проверочной таблице
				in.size++; // увеличиваем количество считанных символов
				col++;// увеличиваем позицию  в строке
				break;
			}
			}
			if (x == IN_CODE_ENDL) { // если считанный символ является символом перевода строки
				in.lines++; // увеличиваем количество строк
				col = 1; // обнуляем позю в строке, т.к. новая строка
			}
		}
		in.text = text;
		return in;
	}
}